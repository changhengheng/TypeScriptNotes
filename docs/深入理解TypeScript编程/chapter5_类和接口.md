# 类和接口

## 类

### **访问修饰符**

TS 类中的属性和方法支持三个访问修饰符：

public

 任何地方都可访问。默认值。

protected

 可由当前类及其子类的实例访问

private

 只可由当前类的实例访问

访问修饰符的作用是不让类暴露过多实现细节，而是只开放规范的 API，供外部使用。

类可以有实例属性，使用 readonly 修饰符定义只读实例属性

### **抽象类**

使用 abstract 关键字创建抽象类。

扩展（继承）类使用 extends 关键字

抽象类不能实例化，而是作为定义其子类的基础使用。

抽象类中可以使用 abstract 关键字定义抽象方法和抽象属性，子类在实现抽象类时也必须实现其抽象方法和抽象属性，否则会报错。

方法有实例方法和静态方法

### super

super 有对象用法和函数用法。对象用法用来调用父类中的方法，比如：`super.take()`。函数用法用来建立父类与子类的联系，只能在子类的 constructor 中使用

父类和子类可以有同名方法。

注意：super 只能访问父类的方法，不能访问父类的属性。

### 以 this 为返回类型

this 可以用作值，也可以用作类型注解：

```ts
class Set {
  has(value: string): boolean {
    // ...
  }
  add(value: number): Set {
    // class类的注解，代表一个Set实例对象
    // ...
  }
}
// 使用this进行类型注解
class Set {
  has(value: string): boolean {
    // ...
  }
  add(value: number): this {
    // this在这里也代表一个Set实例对象，这样比具体类的注解更加方便，因为将
    // this指代交给TS自己去处理，当扩展（作为基类让其他类继承）其他类时，this指向会改变
    // 这样每个子类中都有一个返回值为自身实例对象的add方法，而不必费心添加每个子类的类型注解
    // ...
  }
}
```

## 接口

接口和类型别名完全一致，其实都是一个东西。

接口是一种命名类型的方式，这样就不必在行内定义了。

接口可以扩展任何结构：对象类型、类、其他接口。

接口使用 `interface` 定义，使用 `extends` 扩展（继承）

接口和类型别名的三个区别：

1. 类型别名更常用。类型别名定义的时候，可以使用类型、类型表达式（类型的交集或并集）、值，而接口定义类型的时候只能使用结构，即`{}`

2. 扩展（继承）接口时，TS 会检查扩展的接口是否可赋值给被扩展的接口。而使用类型别名时如果使用了交集运算符，TS 不会进行检查，会强行合并同名类型，造成类型签名重载，而不会抛出编译时错误。
3. 同一作用域 的多个同名接口将自动合并；同一作用域中的多个同名类型别名将导致编译时错误。这个特性称为声明合并。

### 声明合并

声明合并指的是 TS 会自动将多个同名声明组合在一起（TS 声明语句共有 9 种，参考附录）。

#### 接口的声明合并

同名接口会被合并为一个接口来使用，前提是接口中不能有任何冲突（比如属性的类型不同），如果有冲突，TS 会报错。

如果接口中声明了泛型，则同名接口必须使用同样的方式声明泛型，否则在合并时会报错。

注：接口和类型别名的标识符不能重名，重名时 TS 会报错

### 接口的实现

#### 类的实现

接口用 implements 关键字指明某个类满足某个接口（相当于使用接口为类添加了类型约束，因为类不是简单的数据类型，不能以简单的方式添加类型注解）

```ts
interface Person {
  name: string;
}
class implements Person {
  name: string;
}
```

因为接口实际上是对类的类型注解，所以当类不满足注解时，TS 会报错。

接口可以声明实例属性，但是不能带有访问修饰符（public、private、protected），因为根本就没有这种用法。但是可以像对象一样使用 readonly 修饰符来声明某个属性是只读的。

```ts
interface Person {
  readonly name: string;
}
```

一个类可以实现任意多个接口，只要能够满足即可，不同的接口之间使用逗号分隔。

```ts
interface Person {
    name: string
}
interface Animal {
    ...
}
class implements Person,Animal {
    name: string
}
```

#### 对象的实现

直接以类型注解的方式使用

#### 函数的实现

直接以类型注解的方式使用，但要在接口内声明函数的调用签名

### 实现接口还是扩展抽象类

### 类是结构化类型

### 类既声明类，也声明类型
