# 类型全解

**类型**是指一系列值及可以对其执行的操作。

如 boolean 类型指所有的布尔值（只有 true 和 false）以及可以对其进行的操作（如与或非）

## any

TS 编译时一切变量都要有类型，如果没有注解，默认（类型推断）为 any。

any 是兜底类型，包含所有值，并可以对其进行任何操作。也正因 any 类型如此包容，它会导致很多类型检查无法发现的错误。为了避免这些错误，尽量不使用 any 类型，如果非用不可，应该显示注解，而不是由 TS 自己做类型推断。

除 any 类型之外，其余类型推荐让 TS 自己做类型推断。

## 类型的操作

### **类型别名**

类似于使用变量声明为值声明别名，TS 中也可以使用 type 声明为类型声明别名。

```ts
type num = number
const age: num = 12 等价于=> const age: number = 12
```

特点：

1. 类型别名必须显式注解，因为 TS 无法推断出类型别名

2. 类型别名可以替换成源类型，程序语义不受影响

3. 同一类型别名只能声明一次

4. 类型别名采用块级作用域（代码块和函数体中，内部类型别名会覆盖外部的同名类型别名）

5. 可以为一个具体值创建类型别名（类型=值+操作）

   ```ts
   type Color = "red";
   type Color = "blue"; // 这个别名会覆盖上面的类型别名
   ```

### 并集类型和交集类型

TS 提供了类型操作符：

- 并集：`|`
- 交集：`&`

并集类型指的是所有子集类型的集合。也就是说，只要是子集中出现的类型，在并集中都**有可能**出现。而所有子集中都有的类型，在并集中**必然**出现。

交集类型指的是所有子集类型公有的类型的集合。即，只要是交集类型中出现的，所有的子集类型中必然都有。

## any

常用场景：

- 声明一个元素类型任意的数组：

  ```ts
  const arr1: Array<any> = [1, true, "haha"];
  const arr2: any[] = [1, true, "haha"];
  ```

## 枚举 enum

- 使用 enum 声明
- 默认从 0 开始排序，可以定义一个默认数字值，后续排序会自动推导。如果定义的是字符串，则必须为某个枚举键都指定值。
- 可以通过点操作符和中括号操作符访问其中的值或键
- 可以使用值访问，也可以使用键访问

## 对象

结构化类型
“If it looks like a duck, walks like a duck, swims like a duck and quacks like a duck, it’s a duck”——James Whitcomb Riley

四种声明方式：

- object 注解
- Object 注解（尽量避免使用）
- 对象字面量
- 特殊的对象字面量：`{}`（尽量避免使用）

对象字面量方式的功能扩充：

- `?` 修饰符定义可选属性
- `readonly` 修饰符定义只读属性
- 索引签名
  - 特点：一个对象中只能有一条索引签名
  - 语法：`[key:T]:U`，该句法称为索引签名。意思是，在这个对象中，类型为T的键对应的值为U类型。索引签名中键的名称可以是任意词，不一定非得用key。key的类型也可以不标注，直接写成`[key]:U`，或者直接写成`key:U`，从而只限定一个键的值。
