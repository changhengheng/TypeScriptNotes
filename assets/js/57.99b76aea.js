(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{479:function(t,s,a){"use strict";a.r(s);var n=a(65),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"类和接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类和接口"}},[t._v("#")]),t._v(" 类和接口")]),t._v(" "),a("h2",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[t._v("#")]),t._v(" 类")]),t._v(" "),a("h3",{attrs:{id:"访问修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问修饰符"}},[t._v("#")]),t._v(" "),a("strong",[t._v("访问修饰符")])]),t._v(" "),a("p",[t._v("TS 类中的属性和方法支持三个访问修饰符：")]),t._v(" "),a("p",[t._v("public")]),t._v(" "),a("p",[t._v("​ 任何地方都可访问。默认值。")]),t._v(" "),a("p",[t._v("protected")]),t._v(" "),a("p",[t._v("​ 可由当前类及其子类的实例访问")]),t._v(" "),a("p",[t._v("private")]),t._v(" "),a("p",[t._v("​ 只可由当前类的实例访问")]),t._v(" "),a("p",[t._v("访问修饰符的作用是不让类暴露过多实现细节，而是只开放规范的 API，供外部使用。")]),t._v(" "),a("p",[t._v("类可以有实例属性，使用 readonly 修饰符定义只读实例属性")]),t._v(" "),a("h3",{attrs:{id:"抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" "),a("strong",[t._v("抽象类")])]),t._v(" "),a("p",[t._v("使用 abstract 关键字创建抽象类。")]),t._v(" "),a("p",[t._v("扩展（继承）类使用 extends 关键字")]),t._v(" "),a("p",[t._v("抽象类不能实例化，而是作为定义其子类的基础使用。")]),t._v(" "),a("p",[t._v("抽象类中可以使用 abstract 关键字定义抽象方法和抽象属性，子类在实现抽象类时也必须实现其抽象方法和抽象属性，否则会报错。")]),t._v(" "),a("p",[t._v("方法有实例方法和静态方法")]),t._v(" "),a("h3",{attrs:{id:"super"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#super"}},[t._v("#")]),t._v(" super")]),t._v(" "),a("p",[t._v("super 有对象用法和函数用法。对象用法用来调用父类中的方法，比如："),a("code",[t._v("super.take()")]),t._v("。函数用法用来建立父类与子类的联系，只能在子类的 constructor 中使用")]),t._v(" "),a("p",[t._v("父类和子类可以有同名方法。")]),t._v(" "),a("p",[t._v("注意：super 只能访问父类的方法，不能访问父类的属性。")]),t._v(" "),a("h3",{attrs:{id:"以-this-为返回类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#以-this-为返回类型"}},[t._v("#")]),t._v(" 以 this 为返回类型")]),t._v(" "),a("p",[t._v("this 可以用作值，也可以用作类型注解：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("has")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Set "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// class类的注解，代表一个Set实例对象")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用this进行类型注解")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("has")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// this在这里也代表一个Set实例对象，这样比具体类的注解更加方便，因为将")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// this指代交给TS自己去处理，当扩展（作为基类让其他类继承）其他类时，this指向会改变")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这样每个子类中都有一个返回值为自身实例对象的add方法，而不必费心添加每个子类的类型注解")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),a("p",[t._v("接口和类型别名完全一致，其实都是一个东西。")]),t._v(" "),a("p",[t._v("接口是一种命名类型的方式，这样就不必在行内定义了。")]),t._v(" "),a("p",[t._v("接口可以扩展任何结构：对象类型、类、其他接口。")]),t._v(" "),a("p",[t._v("接口使用 "),a("code",[t._v("interface")]),t._v(" 定义，使用 "),a("code",[t._v("extends")]),t._v(" 扩展（继承）")]),t._v(" "),a("p",[t._v("接口和类型别名的三个区别：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("类型别名更常用。类型别名定义的时候，可以使用类型、类型表达式（类型的交集或并集）、值，而接口定义类型的时候只能使用结构，即"),a("code",[t._v("{}")])])]),t._v(" "),a("li",[a("p",[t._v("扩展（继承）接口时，TS 会检查扩展的接口是否可赋值给被扩展的接口。而使用类型别名时如果使用了交集运算符，TS 不会进行检查，会强行合并同名类型，造成类型签名重载，而不会抛出编译时错误。")])]),t._v(" "),a("li",[a("p",[t._v("同一作用域 的多个同名接口将自动合并；同一作用域中的多个同名类型别名将导致编译时错误。这个特性称为声明合并。")])])]),t._v(" "),a("h3",{attrs:{id:"声明合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明合并"}},[t._v("#")]),t._v(" 声明合并")]),t._v(" "),a("p",[t._v("声明合并指的是 TS 会自动将多个同名声明组合在一起（TS 声明语句共有 9 种，参考附录）。")]),t._v(" "),a("h4",{attrs:{id:"接口的声明合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口的声明合并"}},[t._v("#")]),t._v(" 接口的声明合并")]),t._v(" "),a("p",[t._v("同名接口会被合并为一个接口来使用，前提是接口中不能有任何冲突（比如属性的类型不同），如果有冲突，TS 会报错。")]),t._v(" "),a("p",[t._v("如果接口中声明了泛型，则同名接口必须使用同样的方式声明泛型，否则在合并时会报错。")]),t._v(" "),a("p",[t._v("注：接口和类型别名的标识符不能重名，重名时 TS 会报错")]),t._v(" "),a("h3",{attrs:{id:"接口的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口的实现"}},[t._v("#")]),t._v(" 接口的实现")]),t._v(" "),a("p",[t._v("接口用 implements 关键字指明某个类满足某个接口（相当于使用接口为类添加了类型约束，因为类不是简单的数据类型，不能以简单的方式添加类型注解）")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")])]),t._v(" Person "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("因为接口实际上是对类的类型注解，所以当类不满足注解时，TS 会报错。")]),t._v(" "),a("p",[t._v("接口可以声明实例属性，但是不能带有访问修饰符（public、private、protected），因为根本就没有这种用法。但是可以像对象一样使用 readonly 修饰符来声明某个属性是只读的。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("readonly")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("一个类可以实现任意多个接口，只要能够满足即可，不同的接口之间使用逗号分隔。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Animal")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")])]),t._v(" Person"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("Animal "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"实现接口还是扩展抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现接口还是扩展抽象类"}},[t._v("#")]),t._v(" 实现接口还是扩展抽象类")]),t._v(" "),a("h3",{attrs:{id:"类是结构化类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类是结构化类型"}},[t._v("#")]),t._v(" 类是结构化类型")]),t._v(" "),a("h3",{attrs:{id:"类既声明类-也声明类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类既声明类-也声明类型"}},[t._v("#")]),t._v(" 类既声明类，也声明类型")])])}),[],!1,null,null,null);s.default=e.exports}}]);